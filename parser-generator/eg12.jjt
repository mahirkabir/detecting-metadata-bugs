options {
   MULTI=true;
   VISITOR=true;
   NODE_DEFAULT_VOID=true;
   STATIC = false;
 }

PARSER_BEGIN(Eg12)

/** An Arithmetic Grammar. */
public class Eg12 {

  /** Main entry point. */
  public static void main(String args[]) {
    Eg12 t;
    System.out.println("Reading from standard input...");
    try {
      t = new Eg12(new java.io.FileInputStream(args[0]));
    } catch (java.io.FileNotFoundException e) {
      System.out.println("Java Parser Version 1.0.2:  File " + args[0] + " not found.");
      return;
    }
    try {
      ASTStart n = t.Start();
      Eg12Visitor v = new Eg12DumpVisitor();
      n.jjtAccept(v, null);
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
}

PARSER_END(Eg12)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

 TOKEN :
 {
   <RULE: "Rule">
 | <FILE: "file" >
 | <CLASS: "class" >
 | <METHOD: "method" >
 | <FIELD: "field" >
 | <STRING: "String">
 | <BOOL: "bool" >
 | <FUNCTION: "function">

 | <IN: "in">

 | <FOR: "for" >
 | <IF: "if" >
 | <ELSE: "else" >
 | <ASSERT: "assert" >
 | <MSG: "msg" >
 | <EXISTS: "exists">

/*
 | <GETFQN: "getFQN">
 | <GETATTR: "getAttr">
 | <GETNAME: "getName">
 | <SUBSTRING: "substring">
 | <UPPERCASE: "upperCase">
 | <GETARG: "getArg">
 | <CALLEXISTS: "callExists">
 | <GETANNOTATED: "getAnnotated">
 | <JOIN: "join">
 | <GETSN: "getSN">
 | <GETANNOATTR: "getAnnoAttr">
 | <ISEMPTY: "isEmpty">
 | <PATHEXISTS: "pathExists">

 | <INDEXOF: "indexOf">
 | <ENDSWITH: "endsWith">
*/

 | <NOT: "NOT">
 | <AND: "AND">
 | <OR: "OR">
 }

 TOKEN : /* LITERALS */
 {
   <INTEGER_LITERAL:
         <DECIMAL_LITERAL> (["l","L"])?
       | <HEX_LITERAL> (["l","L"])?
       | <OCTAL_LITERAL> (["l","L"])?
   >
 |
   <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
 |
   <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
 |
   <#OCTAL_LITERAL: "0" (["0"-"7"])* >
 |
   <FLOATING_POINT_LITERAL:
         (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
       | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
       | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
       | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
   >
 |
   <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
 |
   <CHARACTER_LITERAL:
       "'"
       (   (~["'","\\","\n","\r"])
         | ("\\"
             ( ["n","t","b","r","f","\\","'","\""]
             | ["0"-"7"] ( ["0"-"7"] )?
             | ["0"-"3"] ["0"-"7"] ["0"-"7"]
             )
           )
       )
       "'"
   >
 |
   <STRING_LITERAL:
       "\""
       (   (~["\"","\\","\n","\r"])
         | ("\\"
             ( ["n","t","b","r","f","\\","'","\""]
             | ["0"-"7"] ( ["0"-"7"] )?
             | ["0"-"3"] ["0"-"7"] ["0"-"7"]
             )
           )
       )*
       "\""
   >
 }

 TOKEN : /* IDENTIFIERS */
 {
   <IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|<COLON>|<DASH>|<STAR>)* >
 |
   <#LETTER:
       [
        "\u0024",
        "\u0041"-"\u005a",
        "\u005f",
        "\u0061"-"\u007a",
        "\u00c0"-"\u00d6",
        "\u00d8"-"\u00f6",
        "\u00f8"-"\u00ff",
        "\u0100"-"\u1fff",
        "\u3040"-"\u318f",
        "\u3300"-"\u337f",
        "\u3400"-"\u3d2d",
        "\u4e00"-"\u9fff",
        "\uf900"-"\ufaff"
       ]
   >
 |
   <#DIGIT:
       [
        "\u0030"-"\u0039",
        "\u0660"-"\u0669",
        "\u06f0"-"\u06f9",
        "\u0966"-"\u096f",
        "\u09e6"-"\u09ef",
        "\u0a66"-"\u0a6f",
        "\u0ae6"-"\u0aef",
        "\u0b66"-"\u0b6f",
        "\u0be7"-"\u0bef",
        "\u0c66"-"\u0c6f",
        "\u0ce6"-"\u0cef",
        "\u0d66"-"\u0d6f",
        "\u0e50"-"\u0e59",
        "\u0ed0"-"\u0ed9",
        "\u1040"-"\u1049"
       ]
   >
  | <#COLON: ":" >
  | <#DASH: "-" >
  | <#STAR: "*" >
 }



 /* SEPARATORS */

 TOKEN :
 {
   <LPAREN: "(" >
 | <RPAREN: ")" >
 | <LBRACE: "{" >
 | <RBRACE: "}" >
 | <LBRACKET: "[" >
 | <RBRACKET: "]" >
 | <SEMICOLON: ";" >
 | <COMMA: "," >
 | <DOT: "." >


 }

 /* OPERATORS */

 TOKEN :
 {
   <ASSIGN: "=" >
 | <GT: ">" >
 | <LT: "<" >
 | <BANG: "!" >
 | <TILDE: "~" >
 | <HOOK: "?" >

 | <EQ: "==" >
 | <LE: "<=" >
 | <GE: ">=" >
 | <NE: "!=" >
 | <SC_OR: "||" >
 | <SC_AND: "&&" >
 | <INCR: "++" >
 | <DECR: "--" >
 | <PLUS: "+" >


 | <SLASH: "/" >
 | <BIT_AND: "&" >
 | <BIT_OR: "|" >
 | <XOR: "^" >
 | <REM: "%" >
 }


/** Main production. */
ASTStart Start() #Start: {}
{
	<RULE> <IDENTIFIER> Block()
	<EOF>

	{ return jjtThis; }
}

void Block(): {}
{
	"{" Stmnt() StmntSuffix() "}"
}

void Stmnt(): {}
{
	ForStmnt()
	| IfStmnt()
	| AssertStmnt()
	| DeclStmnt() ";"
}

void StmntSuffix(): {}
{
	(Stmnt() StmntSuffix())?
}

void ForStmnt(): {}
{
	<FOR> "(" Expression() <IN> Expression() ")" Block()
}

void IfStmnt(): {}
{
	<IF> "(" Expression() ")" Block() IfSuffix()
}

void AssertStmnt(): {}
{
	<ASSERT> "(" Expression() ")" "{" MsgStmnt() ";" "}"
}

void DeclStmnt(): {}
{
	Type() <IDENTIFIER> "=" (FunctionOrId() | Literal())
}

void Expression(): {}
{
	SimExp() ExpSuffix()
}

void IfSuffix(): {}
{
	(<ELSE> Block())?
}

void MsgStmnt(): {}
{
	<MSG> "(" <STRING_LITERAL> MsgSuffix() ")"
}

void MsgSuffix(): {}
{
	("," Expression() MsgSuffix())?
}

void Type(): {}
{
	<FILE>
	| "<" <IDENTIFIER> ">"
	| <CLASS>
	| <METHOD>
	| <FIELD>
	| <STRING>
	| <BOOL>
}

void FunctionOrId(): {}
{
	<IDENTIFIER> FunctionTail()
}

void FunctionTail(): {}
{
	("(" Params() ")")?
}

void SimExp(): {}
{
	FunctionOrId()
	| Literal()
	| Type() <IDENTIFIER>
	| "(" Expression() ")"
	| <EXISTS> "(" Expression() <IN> Expression() ")" "(" Expression() ")"
	| <NOT> SimExp()
}

void ExpSuffix(): {}
{
	(<AND> Expression()
		| <OR> Expression()
		| <EQ> Expression())?
}

void Params(): {}
{
	(SimExp() ParamSuffix())?
}

void ParamSuffix(): {}
{
	("," SimExp() ParamSuffix())?
}

void Literal(): {}
{
	<STRING_LITERAL> | <CHARACTER_LITERAL> | <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL>
}